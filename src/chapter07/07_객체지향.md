# 7. 객체지향
>		객체의 모델링 : 프로그래밍을 하기 위한 설계도
	실행활을 모델링 ----------------> 클래스(class):틀, 설계도 -----------------------> 객체(Object)
					추상화(Abstraction)
				
### 1) 클래스
>		- 객체를 생성하기 위한 틀, 설계도
	- 클래스는 필드(Field), 생성자(Constructor), 메소드(Method)로 구성
	- 클래스의 구성 요소는 캡슐화(Encapsulation)를 통해 내용이 보호된다.
	
### 2) 클래스 구조
>		class 클래스명 { 
		// Field : 전역
		// Constructor : 생성자 메소드 - 객체를 생성할때 호출되는 메소드, new 키워드 뒤에 선언
		// Method : 기능을 정의하고 호출시 객체명.메소드명 형식으로 호출
	}

### 3) 객체
>		클래스라는 틀을 통해 메모리(Heap영역)에 생성된다.
	클래스의 생성자를 new라는 키워드 뒤에 호출하여 생성한다.

###### 예제) 사자, 호랑이, 기린, 코끼리와 같은 동물의 클래스를 도출, 코드를 작성
>		필드생성
	사자(객체) is a 동물(클래스) : O
	동물 is a 사자 : X
	호랑이(객체) is a 동물(클래스)
	기린(객체) is a 동물(클래스)
	코끼리(객체) is a 동물(클래스)
	
>		생성자생성
	사자의 이름은 심바, 호랑이 이름은 호돌이, 기린은 기린이, 코끼리는 코순이
	사자 has a 이름(심바) : O
	이름(심바) has a 사자 : X
	사자나이 5, 호랑이나이 2, 기린나이 5, 코끼리나이 11
	사자 has a 나이(5) : O
	나이(5) has a 사자 : X	
		
>		추상화를 통해 클래스 설계 : 클래스명 -> 동물, 객체 -> 사자, 호랑이, 기린, 코끼리
	class 동물{
		// 필드 : 전역변수 - 형식) 데이터타입 변수명 = 값;
							Stirng 이름;
							int 나이;
		// 생성자 : public 생성자명(){ - 생성자명은 클래스명과 동일하다.
			// 생성될 때 실행하는 기능
		}
		// 메소드
		[접근제어자(public)] [반환타입] [메소드명](){
			// 메소드의 기능
		}
	}

### 4) 생성자
>		클래스를 통해 객체를 생성하는 역할을 진행
	가장 먼저 호출되는 메소드(한 번만 호출됨)
	JVM이 자동으로 호출하여 실행
	호출 위치는 new 생성자();  <-(생성자명 = 클래스명)
	기본 생성자() : public 클래스명(){};
	기본 생성자는 정의시 생략이 가능하다. 단 기본 생성자만 존재하는 경우

### 5) 메소드
>		객체의 기능을 담당하는 역할
	메소드 정의 형식
	[접근제어자][리턴타입]메소드명(매개변수, 파라미터){
		실행문
		return 값;
	}

######용어 정리
	접근제어자 : 
	메소드를 호출하는 범위를 결정
	(public, private, protected, default(package))
	<br>
	리턴타입 : 
	메소드가 실행을 한 결과를 호출한 곳에 리턴(전달)하는 경우 전의
	리턴값은 return 키워드 뒤에 입력, 만약 리턴값이 없으면 void 사용
	ex) public int getNumber(){
		return 100;
	} <- getNumber메소드 실행 시 int 타입의 정수 100 반환
	<br>
	매개변수(파라미터) : 
	메소드 호출 시 메소드의 기능을 실행하기 위해 필요한 값들을 전달하는 역할
	실행문에서 사용되는 데이터타입을 맞추어 입력을 받는다.
	매개변수의 갯수는 정해지지 않음 임의로 정의 가능
	매개변수의 데이터 타입은 기본형, 참조형 모두 가능
	ex) add(값1, 값2); 값1과 값2를 add 메소드 호출 시 입력받아 실행을 하는 메소드
	add(10,20); --> 출력 형식 : sum = 30
	public void add(int num1, int num2){
		// num1 <- 10
		// num2 <- 20
		System.out.println("sum = " + (num1 + num2));	
	}
	<br>

### <<리턴타입과 매개변수에 따른 메소드 정의 예>>
######(1) 리턴타입 X, 매개변수 X
>		public void method1() {
		System.out.println("method1 --> 리턴타입 X, 매개변수 X");
	}
	호출 : method1
	출력 : System.out.println("method1 --> 리턴타입 X, 매개변수 X");

######(2) 리턴타입 O, 매개변수 X
>		public int method2() {
		int num1 = 10;
		int num2 = 20;
		return (num1 + num2);
	}
	호출 : method2
	리턴값 : 30

######(3) 리턴타입 X, 매개변수 O
>		public void method3(int num1, int num2) {
		System.out.println("method3 --> " + (num1 + num2));
	}
		public void method3(String name) {
		System.out.println("method3 --> " + name);
	}
	호출 : method3(10,20) 또는 method3("홍길동")
	출력 : System.out.println("method3 --> 30"); << method3(10,20)
	출력 : System.out.println("method3 --> 홍길동");	<< method3("홍길동")

######(4) 리턴타입 O, 매개변수 O
>		public int method4(int num1, int num2) {
		return (num1 + num2);
	}
	호출 : method4(10,20)
	리턴값 : 30

### 6) 메소드 오버로딩
	하나의 클래스에 동일한 이름을 가진 메소드를 여러개 정의하는 것
	단 매개 변수의 갯수와 타입은 서로 달라야한다.
	리턴 타입과는 상관없다.

### 7) 가변 매개변수(Variable Aguments)
	매개변수 입력 시 갯수에 제한없이 동일한 데이터타입으로 입력가능
	형식 : 메소드명(데이터타입 ... 변수명 ) { } 
	
	가변 매개변수(Variable Aguments)는 자바스크립트의 스프레드 연산자와 모양은 동일하나
	기능이 조금씩 다르므로 주의
	